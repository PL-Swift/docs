{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PL/Swift Documentation PL/Swift allows you to write custom SQL functions and types for the PostgreSQL database server in the Swift programming language. What is an PostgreSQL extension? The PostgreSQL database server is quite modular and can be extended with custom SQL functions and custom SQL types. Such extensions can be written in PSQL itself, in scripting languages such as Python or TCL, and in plain C. TODO: write more","title":"Introduction"},{"location":"#plswift-documentation","text":"PL/Swift allows you to write custom SQL functions and types for the PostgreSQL database server in the Swift programming language.","title":"PL/Swift Documentation"},{"location":"#what-is-an-postgresql-extension","text":"The PostgreSQL database server is quite modular and can be extended with custom SQL functions and custom SQL types. Such extensions can be written in PSQL itself, in scripting languages such as Python or TCL, and in plain C. TODO: write more","title":"What is an PostgreSQL extension?"},{"location":"about/","text":"Bringing Swift to the Backend of the Backend's Backend . Contact Hey, we love feedback. Join the mailing list, Slack channel or just drop us an email to tell us why this is crap (or not?). Mailing List Slack info@apacheexpress.io Mkdocs Built with MkDocs using a theme provided by Read the Docs . Who PL/Swift is brought to you by the ZeeZide GmbH. Imprint .","title":"About"},{"location":"about/#contact","text":"Hey, we love feedback. Join the mailing list, Slack channel or just drop us an email to tell us why this is crap (or not?). Mailing List Slack info@apacheexpress.io","title":"Contact"},{"location":"about/#mkdocs","text":"Built with MkDocs using a theme provided by Read the Docs .","title":"Mkdocs"},{"location":"about/#who","text":"PL/Swift is brought to you by the ZeeZide GmbH. Imprint .","title":"Who"},{"location":"install/","text":"PL/Swift Installation PL/Swift should install fine on pretty much any Unix system that can run PostgreSQL. Including exotic setups like Raspberry Pi systems. We also provide a macOS Homebrew tap which makes it really easy to install PL/Swift and its dependencies on macOS. We highly recommend that over a custom install. On the Linux side we test w/ Ubuntu Trusty and Xenial, though it should work pretty much anywhere. Install on macOS using Homebrew Got no Homebrew? Get it! Then add the PL/Swift tap and install plswift: brew tap PL-Swift/plswift brew install plswift Install using Docker There is also a Docker image w/ Swift, PostgreSQL and PL/Swift. Simply run it using: docker run --rm -it --name plswift helje5/swift-pgdev /bin/bash You may want to expose the PG port ( -p 127.0.0.1:5432:5432 ), or not. Within the image, start PostgreSQL (swift user pwd is just swift ): sudo /etc/init.d/postgresql start swift pl validate And you are good. The image contains Emacs, Swift, PL/Swift, psql, and all the other stuff you need to play. Install on Linux (or macOS w/o Homebrew) On macOS: We strongly advise that you rather use Homebrew, more importantly the Apache provided by Homebrew. Ubuntu packages required (assuming you have Swift installed already): sudo apt-get update sudo apt-get install \\ curl pkg-config postgresql libpq-dev postgresql-server-dev-all Install PL/Swift: curl -L -o plswift.tgz \\ https://github.com/PL-Swift/plswift/archive/0.5.1.tar.gz tar zxf plswift.tgz && cd PLSwift-0.5.1 make sudo make install That puts PL/Swift into /usr/local . If you want to have it in /usr , do: sudo make prefix=/usr install Check whether the installation is OK You can call swift pl validate to make sure the installation is OK: The Swift PostgreSQL build environment looks sound. srcroot: /Users/helge module: helge config: debug product: /Users/helge/.build/helge.so version: sql-setup: pg_config: /usr/local/bin/pg_config moddir: /usr/local/lib/postgresql extdir: /usr/local/share/postgresql/extension/ PL/Swift: /usr/local swift: 5.0.1 tools: 5.0 ERROR: Missing extension control file: PLSwift.control ERROR: Missing setup file: (you can ignore the ERRORs at the bottom, they are only relevant within extensions) Troubleshooting If something isn't working in a Homebrew setup, check whether: brew doctor outputs anything unusual. Sometimes, you may have both, PostgreSQL binaries via Homebrew, and for example the PostgreSQL.app. This can result in such: helge=# CREATE EXTENSION \"hello\"; ERROR: incompatible library \"/Applications/Postgres.app/Contents/Versions/9.4/lib/postgresql/hello.so\": version mismatch DETAIL: Server is version 9.4, library is version 10.0. Here, PostgreSQL.app is at 9.4, while Brew already has PostgreSQL 10 and hence produces a conflict. When you run into this, it is probably easiest to link /usr/local/bin/pg_config to the one you want to use. For example: ln -sf `which pg_config` /usr/local/bin/pg_config and reinstall plswift: brew reinstall plswift Recompile/reinstall the extension and all should be good. Finding Help If you need any help, feel free to ask on the Mailing List or our Slack channel .","title":"Installation"},{"location":"install/#plswift-installation","text":"PL/Swift should install fine on pretty much any Unix system that can run PostgreSQL. Including exotic setups like Raspberry Pi systems. We also provide a macOS Homebrew tap which makes it really easy to install PL/Swift and its dependencies on macOS. We highly recommend that over a custom install. On the Linux side we test w/ Ubuntu Trusty and Xenial, though it should work pretty much anywhere.","title":"PL/Swift Installation"},{"location":"install/#install-on-macos-using-homebrew","text":"Got no Homebrew? Get it! Then add the PL/Swift tap and install plswift: brew tap PL-Swift/plswift brew install plswift","title":"Install on macOS using Homebrew"},{"location":"install/#install-using-docker","text":"There is also a Docker image w/ Swift, PostgreSQL and PL/Swift. Simply run it using: docker run --rm -it --name plswift helje5/swift-pgdev /bin/bash You may want to expose the PG port ( -p 127.0.0.1:5432:5432 ), or not. Within the image, start PostgreSQL (swift user pwd is just swift ): sudo /etc/init.d/postgresql start swift pl validate And you are good. The image contains Emacs, Swift, PL/Swift, psql, and all the other stuff you need to play.","title":"Install using Docker"},{"location":"install/#install-on-linux-or-macos-wo-homebrew","text":"On macOS: We strongly advise that you rather use Homebrew, more importantly the Apache provided by Homebrew. Ubuntu packages required (assuming you have Swift installed already): sudo apt-get update sudo apt-get install \\ curl pkg-config postgresql libpq-dev postgresql-server-dev-all Install PL/Swift: curl -L -o plswift.tgz \\ https://github.com/PL-Swift/plswift/archive/0.5.1.tar.gz tar zxf plswift.tgz && cd PLSwift-0.5.1 make sudo make install That puts PL/Swift into /usr/local . If you want to have it in /usr , do: sudo make prefix=/usr install","title":"Install on Linux (or macOS w/o Homebrew)"},{"location":"install/#check-whether-the-installation-is-ok","text":"You can call swift pl validate to make sure the installation is OK: The Swift PostgreSQL build environment looks sound. srcroot: /Users/helge module: helge config: debug product: /Users/helge/.build/helge.so version: sql-setup: pg_config: /usr/local/bin/pg_config moddir: /usr/local/lib/postgresql extdir: /usr/local/share/postgresql/extension/ PL/Swift: /usr/local swift: 5.0.1 tools: 5.0 ERROR: Missing extension control file: PLSwift.control ERROR: Missing setup file: (you can ignore the ERRORs at the bottom, they are only relevant within extensions)","title":"Check whether the installation is OK"},{"location":"install/#troubleshooting","text":"If something isn't working in a Homebrew setup, check whether: brew doctor outputs anything unusual. Sometimes, you may have both, PostgreSQL binaries via Homebrew, and for example the PostgreSQL.app. This can result in such: helge=# CREATE EXTENSION \"hello\"; ERROR: incompatible library \"/Applications/Postgres.app/Contents/Versions/9.4/lib/postgresql/hello.so\": version mismatch DETAIL: Server is version 9.4, library is version 10.0. Here, PostgreSQL.app is at 9.4, while Brew already has PostgreSQL 10 and hence produces a conflict. When you run into this, it is probably easiest to link /usr/local/bin/pg_config to the one you want to use. For example: ln -sf `which pg_config` /usr/local/bin/pg_config and reinstall plswift: brew reinstall plswift Recompile/reinstall the extension and all should be good.","title":"Troubleshooting"},{"location":"install/#finding-help","text":"If you need any help, feel free to ask on the Mailing List or our Slack channel .","title":"Finding Help"},{"location":"links/","text":"PostgreSQL Link Collection There is plenty of information on the Interwebs about \"PostgreSQL\": Official Apache Documentation PostgreSQL mod_swift , write Apache2 modules in Swift PostgreSQL Server Programming PostgreSQL C Language Functions","title":"Link Collection"},{"location":"links/#postgresql-link-collection","text":"There is plenty of information on the Interwebs about \"PostgreSQL\":","title":"PostgreSQL Link Collection"},{"location":"links/#official-apache-documentation","text":"PostgreSQL mod_swift , write Apache2 modules in Swift PostgreSQL Server Programming PostgreSQL C Language Functions","title":"Official Apache Documentation"},{"location":"tools/","text":"PL/Swift Tools PL/Swift comes with a set of CLI tools that integrate with the Swift Package Manager. The tools enhance the Swift Package Manager to be able to build native PostgreSQL extensions, configure them and run them. All of them are invoked like: swift pl <subcommand> If the toolname is omitted, you get a small help: $ swift pl usage: swift pl <subcommand> Available subcommands are: init Setup directory as a Swift PostgreSQL Package. build Build Swift Package as a PostgreSQL loadable module. install Install module into PostgreSQL server. validate Check PostgreSQL build environment. Try 'swift pl <subcommand> help' for details. swift pl init Prepare a directory as a Swift PostgreSQL extension. $ mkdir base36 && cd base36 $ swift pl init The Swift PostgreSQL build environment looks sound. module: base36 config: debug product: /Users/helge/trump/base36/.build/base36.so pg_config: /Applications/Postgres.app/Contents/Versions/9.4/bin/pg_config PL/Swift: /usr/local This creates a set of files: - the control file for the package - the SQL file to register the package functions w/ PostgreSQL - a boilerplate file which contains the C function registration - a file where the actual Swift functions are kept swift pl build swift pl build first invokes swift build and subsequently converts the build results into an PostgreSQL extension shared library. $ swift pl build Fetching https://github.com/PL-Swift/PLSwift.git Fetching https://github.com/PL-Swift/CPLSwift.git Cloning https://github.com/PL-Swift/PLSwift.git Resolving https://github.com/PL-Swift/PLSwift.git at 0.0.4 Cloning https://github.com/PL-Swift/CPLSwift.git Resolving https://github.com/PL-Swift/CPLSwift.git at 0.0.1 Compile Swift Module 'PLSwift' (3 sources) Compile Swift Module 'base36' (2 sources) $ ls -hl .build/base36.so -rwxr-xr-x 1 helge staff 74K Jan 6 14:52 .build/base36.so swift pl install The swift pl install command will install the extension into your local PostgreSQL server. That is, it will copy the build binary extension, the control file and the SQL registration file into your PostgreSQL server. $ swift pl install swift pl validate swift pl validate just checks whether a build is likely to be successful and prints out the configuration assumptions it has. $ swift pl validate The Swift PostgreSQL build environment looks sound. srcroot: /Users/helge/trump/base36 module: base36 config: debug product: /Users/helge/trump/base36/.build/base36.so version: 0.0.1 sql-setup: base36--0.0.1.sql pg_config: /Applications/Postgres.app/Contents/Versions/9.4/bin/pg_config moddir: /Applications/Postgres.app/Contents/Versions/9.4/lib/postgresql extdir: /Applications/Postgres.app/Contents/Versions/9.4/share/postgresql/extension/ PL/Swift: /usr/local swift: 4.0.3","title":"Tools Reference"},{"location":"tools/#plswift-tools","text":"PL/Swift comes with a set of CLI tools that integrate with the Swift Package Manager. The tools enhance the Swift Package Manager to be able to build native PostgreSQL extensions, configure them and run them. All of them are invoked like: swift pl <subcommand> If the toolname is omitted, you get a small help: $ swift pl usage: swift pl <subcommand> Available subcommands are: init Setup directory as a Swift PostgreSQL Package. build Build Swift Package as a PostgreSQL loadable module. install Install module into PostgreSQL server. validate Check PostgreSQL build environment. Try 'swift pl <subcommand> help' for details.","title":"PL/Swift Tools"},{"location":"tools/#swift-pl-init","text":"Prepare a directory as a Swift PostgreSQL extension. $ mkdir base36 && cd base36 $ swift pl init The Swift PostgreSQL build environment looks sound. module: base36 config: debug product: /Users/helge/trump/base36/.build/base36.so pg_config: /Applications/Postgres.app/Contents/Versions/9.4/bin/pg_config PL/Swift: /usr/local This creates a set of files: - the control file for the package - the SQL file to register the package functions w/ PostgreSQL - a boilerplate file which contains the C function registration - a file where the actual Swift functions are kept","title":"swift pl init"},{"location":"tools/#swift-pl-build","text":"swift pl build first invokes swift build and subsequently converts the build results into an PostgreSQL extension shared library. $ swift pl build Fetching https://github.com/PL-Swift/PLSwift.git Fetching https://github.com/PL-Swift/CPLSwift.git Cloning https://github.com/PL-Swift/PLSwift.git Resolving https://github.com/PL-Swift/PLSwift.git at 0.0.4 Cloning https://github.com/PL-Swift/CPLSwift.git Resolving https://github.com/PL-Swift/CPLSwift.git at 0.0.1 Compile Swift Module 'PLSwift' (3 sources) Compile Swift Module 'base36' (2 sources) $ ls -hl .build/base36.so -rwxr-xr-x 1 helge staff 74K Jan 6 14:52 .build/base36.so","title":"swift pl build"},{"location":"tools/#swift-pl-install","text":"The swift pl install command will install the extension into your local PostgreSQL server. That is, it will copy the build binary extension, the control file and the SQL registration file into your PostgreSQL server. $ swift pl install","title":"swift pl install"},{"location":"tools/#swift-pl-validate","text":"swift pl validate just checks whether a build is likely to be successful and prints out the configuration assumptions it has. $ swift pl validate The Swift PostgreSQL build environment looks sound. srcroot: /Users/helge/trump/base36 module: base36 config: debug product: /Users/helge/trump/base36/.build/base36.so version: 0.0.1 sql-setup: base36--0.0.1.sql pg_config: /Applications/Postgres.app/Contents/Versions/9.4/bin/pg_config moddir: /Applications/Postgres.app/Contents/Versions/9.4/lib/postgresql extdir: /Applications/Postgres.app/Contents/Versions/9.4/share/postgresql/extension/ PL/Swift: /usr/local swift: 4.0.3","title":"swift pl validate"},{"location":"usage/","text":"Hello World But lets do a simple base36 module for demonstration purposes. Setup Module Setup a new directory and initialize it as an PostgreSQL extension: $ mkdir base36 && cd base36 $ swift pl init The Swift PostgreSQL build environment looks sound. module: base36 config: debug product: /Users/helge/trump/base36/.build/base36.so pg_config: /Applications/Postgres.app/Contents/Versions/9.4/bin/pg_config PL/Swift: /usr/local This creates a Swift Package Manager module and places relevant extension files into it: $ tree . \u251c\u2500\u2500 Package.swift \u251c\u2500\u2500 Sources \u2502 \u2514\u2500\u2500 helloswiftpl \u2502 \u251c\u2500\u2500 base36-ext.swift \u2502 \u2514\u2500\u2500 base36.swift \u251c\u2500\u2500 base36--0.0.1.sql \u2514\u2500\u2500 base36.control 1 directory, 5 files The Package.swift just loads the PL/Swift wrapper module we provide: import PackageDescription let package = Package( name: \"base36\", dependencies: [ .Package(url: \"https://github.com/PL-Swift/PLSwift.git\", from: \"0.5.1\") ] ) The base36.swift source file contains a a sample Swift SQL function. The file can be named anything (but main.swift, which would produce a tool instead of a library ;-) import Foundation func hello() -> String { return \"Hello Schwifty World!\" } The base36-ext.swift file contains all the boilerplate to export the Swift function towards PostgreSQL: import Foundation import CPLSwift import PLSwift // MARK: - Hello Function Declaration /* * To add more functions, you need to: * - add a main `func xyz(fcinfo: FunctionCallInfo) -> Datum` * - add a mandatory ABI function (just returns PG_FUNCTION_INFO_V1) * - load the function in the base36.sql file * * The functions need proper \"C names\", so that PostgreSQL can find them. The * names are assigned using the `@_cdecl` attribute. */ @_cdecl(\"pg_finfo_base36_hello\") public func hello_abi() -> UnsafeRawPointer { return PG_FUNCTION_INFO_V1 } @_cdecl(\"base36_hello\") public func hello(fcinfo: FunctionCallInfo) -> Datum { return hello().pgDatum } // MARK: - PostgreSQL Extension Marker @_cdecl(\"Pg_magic_func\") public func PG_MAGIC_BLOCK() -> UnsafeRawPointer { return PGExtensionMagicStruct } Intermission: @_cdecl PostgreSQL is written in C and when loading objects, expects the exported functions, data, etc to be in \"C-style\" (conforming to the platforms C ABI). While Swift interoperates with C ABI code just fine, it does not use the C ABI, but - like C++ - \"mangles\" the names. This is to support type overloading, module, etc - the details don't matter here. The important thing is that Swift functions need to be given a \"C name\" to be accessible by a C caller like PostgreSQL. This is what the @_cdecl function attribute is good for. Consider this: @_cdecl(\"base36_hello\") func hello(...) {} Within the Swift module, the name of the function is just hello . In the compiled Swift binary this becomes something like (run nm -gU on the shared library to check that): __T006base365helloSuSpySC20FunctionCallInfoDataVG6fcinfo_tF This can't be consumed by PostgreSQL. By adding the @_cdecl(\"base36_hello\") , the binary will also contain a plain reference: _base36_hello Which is what PostgreSQL will find and load. Explanation of the Source The boilerplate contains the things exported by the extension using the C/PG ABI. When PostgreSQL loads the dynamic object, it will use the dlsym family of functions to locate entry points into the extension. There is one 'marker' entry point, the PG_MAGIC_BLOCK . This has to be declared exactly once in the extension and tells PG that this is indeed a valid PostgreSQL extension, plus the PostgreSQL API the module was compiled against etc: @_cdecl(\"Pg_magic_func\") public func PG_MAGIC_BLOCK() -> UnsafeRawPointer { return PGExtensionMagicStruct } In addition to that, there are two functions for each SQL function, the actual function which is called by PostgreSQL when the function is used from within PostgreSQL: @_cdecl(\"base36_hello\") public func hello(fcinfo: FunctionCallInfo) -> Datum and an \"ABI version function\". The ABI version function is always the same, and PostgreSQL only supports this one ABI v1. Declaring the function is still mandatory: @_cdecl(\"pg_finfo_base36_hello\") func hello_abi() -> UnsafeRawPointer { return PG_FUNCTION_INFO_V1 } Notice that the C name is the same like the actual function name, but with a pg_finfo_ prefix. Just return the PG_FUNCTION_INFO_V1 constant. Back to the actual function, it receives a FunctionCallInfo pointer. The struct this is pointing to, contains the arguments the SQL function was called with and a few more things. For example if the first argument is an int, it can be extracted like this: let firstArgument = fcinfo.pointee[int: 0] The function returns a Datum . Datum is an opaque PostgreSQL type which can carry all kinds of values. Same thing like a Swift Any essentially. PLSwift contains a protocol which can turn various Swift types into Datum values. For example to return a SQL TEXT, you can simply do this: return \"Hello\".pgDatum That is what the boilerplate does. We recommend to keep it in a separate file from the actual implementation of the function. It is ugly and you don't want to look at that uglyness all the time. Build Module Now that we looked at the source, lets build the module: swift pl build first invokes swift build and subsequently converts the build results into an PostgreSQL extension shared library ( base36.so ). $ swift pl build Fetching https://github.com/PL-Swift/CPLSwift.git Fetching https://github.com/PL-Swift/PLSwift.git Completed resolution in 2.83s Cloning https://github.com/PL-Swift/CPLSwift.git Resolving https://github.com/PL-Swift/CPLSwift.git at 1.0.3 Cloning https://github.com/PL-Swift/PLSwift.git Resolving https://github.com/PL-Swift/PLSwift.git at 0.5.1 [2/2] Compiling Swift Module 'base36' (2 sources) $ ls -hl .build/base36.so -rwxr-xr-x 1 helge staff 74K Jan 6 14:52 .build/base36.so Install Module The swift pl install command will install the extension into your local PostgreSQL server. That is, it will copy the build binary extension, the control file and the SQL registration file into your PostgreSQL server. $ swift pl install Load Module into PostgreSQL Once you installed the module, you can simply load it into your PostgreSQL like that: CREATE EXTENSION \"base36\"; and then call functions, like for example: SELECT * FROM base36_hello(); When you are in psql , you can use \\df to list the registered functions.","title":"Using PL/Swift"},{"location":"usage/#hello-world","text":"But lets do a simple base36 module for demonstration purposes.","title":"Hello World"},{"location":"usage/#setup-module","text":"Setup a new directory and initialize it as an PostgreSQL extension: $ mkdir base36 && cd base36 $ swift pl init The Swift PostgreSQL build environment looks sound. module: base36 config: debug product: /Users/helge/trump/base36/.build/base36.so pg_config: /Applications/Postgres.app/Contents/Versions/9.4/bin/pg_config PL/Swift: /usr/local This creates a Swift Package Manager module and places relevant extension files into it: $ tree . \u251c\u2500\u2500 Package.swift \u251c\u2500\u2500 Sources \u2502 \u2514\u2500\u2500 helloswiftpl \u2502 \u251c\u2500\u2500 base36-ext.swift \u2502 \u2514\u2500\u2500 base36.swift \u251c\u2500\u2500 base36--0.0.1.sql \u2514\u2500\u2500 base36.control 1 directory, 5 files The Package.swift just loads the PL/Swift wrapper module we provide: import PackageDescription let package = Package( name: \"base36\", dependencies: [ .Package(url: \"https://github.com/PL-Swift/PLSwift.git\", from: \"0.5.1\") ] ) The base36.swift source file contains a a sample Swift SQL function. The file can be named anything (but main.swift, which would produce a tool instead of a library ;-) import Foundation func hello() -> String { return \"Hello Schwifty World!\" } The base36-ext.swift file contains all the boilerplate to export the Swift function towards PostgreSQL: import Foundation import CPLSwift import PLSwift // MARK: - Hello Function Declaration /* * To add more functions, you need to: * - add a main `func xyz(fcinfo: FunctionCallInfo) -> Datum` * - add a mandatory ABI function (just returns PG_FUNCTION_INFO_V1) * - load the function in the base36.sql file * * The functions need proper \"C names\", so that PostgreSQL can find them. The * names are assigned using the `@_cdecl` attribute. */ @_cdecl(\"pg_finfo_base36_hello\") public func hello_abi() -> UnsafeRawPointer { return PG_FUNCTION_INFO_V1 } @_cdecl(\"base36_hello\") public func hello(fcinfo: FunctionCallInfo) -> Datum { return hello().pgDatum } // MARK: - PostgreSQL Extension Marker @_cdecl(\"Pg_magic_func\") public func PG_MAGIC_BLOCK() -> UnsafeRawPointer { return PGExtensionMagicStruct }","title":"Setup Module"},{"location":"usage/#intermission-_cdecl","text":"PostgreSQL is written in C and when loading objects, expects the exported functions, data, etc to be in \"C-style\" (conforming to the platforms C ABI). While Swift interoperates with C ABI code just fine, it does not use the C ABI, but - like C++ - \"mangles\" the names. This is to support type overloading, module, etc - the details don't matter here. The important thing is that Swift functions need to be given a \"C name\" to be accessible by a C caller like PostgreSQL. This is what the @_cdecl function attribute is good for. Consider this: @_cdecl(\"base36_hello\") func hello(...) {} Within the Swift module, the name of the function is just hello . In the compiled Swift binary this becomes something like (run nm -gU on the shared library to check that): __T006base365helloSuSpySC20FunctionCallInfoDataVG6fcinfo_tF This can't be consumed by PostgreSQL. By adding the @_cdecl(\"base36_hello\") , the binary will also contain a plain reference: _base36_hello Which is what PostgreSQL will find and load.","title":"Intermission: @_cdecl"},{"location":"usage/#explanation-of-the-source","text":"The boilerplate contains the things exported by the extension using the C/PG ABI. When PostgreSQL loads the dynamic object, it will use the dlsym family of functions to locate entry points into the extension. There is one 'marker' entry point, the PG_MAGIC_BLOCK . This has to be declared exactly once in the extension and tells PG that this is indeed a valid PostgreSQL extension, plus the PostgreSQL API the module was compiled against etc: @_cdecl(\"Pg_magic_func\") public func PG_MAGIC_BLOCK() -> UnsafeRawPointer { return PGExtensionMagicStruct } In addition to that, there are two functions for each SQL function, the actual function which is called by PostgreSQL when the function is used from within PostgreSQL: @_cdecl(\"base36_hello\") public func hello(fcinfo: FunctionCallInfo) -> Datum and an \"ABI version function\". The ABI version function is always the same, and PostgreSQL only supports this one ABI v1. Declaring the function is still mandatory: @_cdecl(\"pg_finfo_base36_hello\") func hello_abi() -> UnsafeRawPointer { return PG_FUNCTION_INFO_V1 } Notice that the C name is the same like the actual function name, but with a pg_finfo_ prefix. Just return the PG_FUNCTION_INFO_V1 constant. Back to the actual function, it receives a FunctionCallInfo pointer. The struct this is pointing to, contains the arguments the SQL function was called with and a few more things. For example if the first argument is an int, it can be extracted like this: let firstArgument = fcinfo.pointee[int: 0] The function returns a Datum . Datum is an opaque PostgreSQL type which can carry all kinds of values. Same thing like a Swift Any essentially. PLSwift contains a protocol which can turn various Swift types into Datum values. For example to return a SQL TEXT, you can simply do this: return \"Hello\".pgDatum That is what the boilerplate does. We recommend to keep it in a separate file from the actual implementation of the function. It is ugly and you don't want to look at that uglyness all the time.","title":"Explanation of the Source"},{"location":"usage/#build-module","text":"Now that we looked at the source, lets build the module: swift pl build first invokes swift build and subsequently converts the build results into an PostgreSQL extension shared library ( base36.so ). $ swift pl build Fetching https://github.com/PL-Swift/CPLSwift.git Fetching https://github.com/PL-Swift/PLSwift.git Completed resolution in 2.83s Cloning https://github.com/PL-Swift/CPLSwift.git Resolving https://github.com/PL-Swift/CPLSwift.git at 1.0.3 Cloning https://github.com/PL-Swift/PLSwift.git Resolving https://github.com/PL-Swift/PLSwift.git at 0.5.1 [2/2] Compiling Swift Module 'base36' (2 sources) $ ls -hl .build/base36.so -rwxr-xr-x 1 helge staff 74K Jan 6 14:52 .build/base36.so","title":"Build Module"},{"location":"usage/#install-module","text":"The swift pl install command will install the extension into your local PostgreSQL server. That is, it will copy the build binary extension, the control file and the SQL registration file into your PostgreSQL server. $ swift pl install","title":"Install Module"},{"location":"usage/#load-module-into-postgresql","text":"Once you installed the module, you can simply load it into your PostgreSQL like that: CREATE EXTENSION \"base36\"; and then call functions, like for example: SELECT * FROM base36_hello(); When you are in psql , you can use \\df to list the registered functions.","title":"Load Module into PostgreSQL"}]}